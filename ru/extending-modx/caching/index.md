---
title: "Кэширование"
translation: "extending-modx/caching"
---

Кэшируя повторно используемые данные, можно предотвратить множество запросов к базе данных, что приведет к повышению производительности. MODX Revolution предлагает ряд различных функций кэширования на разных уровнях в приложении. Кэширование в MODX в основном обрабатывается базовым классом `modCacheManager`, который расширяет класс `xPDOCacheManager` и позволяет использовать обработчики кэша, зависящие от раздела. Реализация по умолчанию записывает кэши в файлы в папке `core/cache/`.

Если вы определили пользовательский ключ `MODX_CONFIG_KEY`, менеджер кэша выполнит запись в `core/cache/MODX_CONFIG_KEY/`

## Общая терминология кэширования и поведение

MODX использует разные **разделы** для отдельных типов кэшируемых данных. Упрощенно, раздел - это папка в директории `core/cache/`, но настоящая ценность разделов в том, что каждому разделу могут быть назначены разные обработчики кэша. **Обработчики кэша** являются производными от класса `xPDOCache` и предоставляют единый API для хранения, чтения и удаления записей кэша.

Обработчик кэша **по умолчанию** `xPDOFileCache` записывает кэш в файловую систему в папке`core/cache/`, но в ядре доступны также другие обработчики кэша для APC (`xPDOAPCCache`), `memcache(d)` (`xPDOMemCache`, `xPDOMemCached`) и `WinCache` (`xPDOWinCache`).

## Разделы основного кэша MODX

В ядре несколько разделов. Их можно легко определить, просмотрев папку `core/cache/` с конфигурацией кэша по умолчанию.

Обычно вам не нужно работать с кэшированными данными напрямую (вместо этого используйте доступные API), но для понимания ядра MODX здесь мы рассмотрим основные разделы и кратко опишем их назначение и содержание.

Как мы обсудим позже, пользовательские провайдеры также могут быть использованы в разработке.

-   **action_map** содержит большой массив всех действий (идентификаторов, ссылающихся на контроллеры и пространства имен), которые могут быть доступны в менеджере. Поскольку действия устарели и больше не используются в 2.3, никогда не полагайтесь на них.
-   **auto_publish** содержит метку времени Unix, которая определяет, когда ресурс должен быть автоматически опубликован или распубликован (см. `ModCacheManager.autoPublish()`)
-   **context_settings** для каждого контекста на сайте содержит карту ресурсов (идентификаторы родительских и дочерних документов), карту псевдонимов, используемые в контексте плагины и политики доступа.
-   **db** раздел кэша базы данных используется, когда включена системная или контекстная настройка `cache_db`, и содержит необработанные наборы результатов для запросов xPDO `getObject`/`getCollection`. Подробнее об этом ниже.
-   **includes** - на самом деле, это не раздел кэша, но он содержит файлы PHP, где сниппеты и плагины заключены в вызовы функций для легкого выполнения ядром. Смотрите сценарии для раздела кэша для сниппетов и плагинов.
-   **logs** - это также не раздел кэша, но содержит файл error.log и иногда другие файлы журнала (например, журнал установки).
-   **menu** cодержит для каждого языка менеджера многомерный массив верхнего меню менеджера.
-   **mgr** не является настоящим разделом кэша, но используется Smarty и Google Minify в 2.2 для записи файлов кэша.
-   **registry** - это директория по умолчанию для modRegistry, в которую записываются журналы регистрации файлов. Не является настоящим разделом кэша.
-   **resource** содержит организованный по контексту и идентификатору ресурса механизм частичного кэширования ресурсов. Эти файлы кэша содержат метаданные для ресурса, кэшированное представление ресурса (\_content) с оставшимися без кэширования тегами, политиками доступа к ресурсу и элементами и их источниками, используемые при обработке ресурса.
-   **rss** не является настоящим разделом кэша, но используется MagpieRSS (виджеты RSS панели) для записи в кеш.
-   **scripts** содержит источник сниппетов и плагинов, которые впоследствии записываются в папку кэша includes.
-   **setup** не является настоящим разделом кэша, но используется инсталлятором MODX для кэширования шаблонов Smarty.
-   **system_settings** содержит глобальную конфигурацию MODX и системные настройки. Этот раздел загружается первым по запросам в MODX. Поскольку альтернативные обработчики кэша для разделов хранятся в системных настройках, этот раздел не может быть загружен из другого обработчика кэша таким образом.

Чтобы изменить обработчик кэша для определенного раздела кэша, просто создайте новый системный (или контекстный) параметр с именем `cache_PARTITION_handler` (например, `cache_resource_handler` или `cache_scripts_handler`) и присвойте ему значение обработчика кэша, который вы хотели бы использовать. По умолчанию используется `xPDOFileCache`, однако и другие обработчики доступны для `APC`, `memcache`(d) и `wincache`.

Обратите внимание, что в MODX 2.0.x система кэша довольно сильно отличалась. Доступные разделы были иными, а системные настройки сохранялись в `core/cache/config.cache.php`. Если вы все еще используете MODX 2.0.x, вам следует потратить больше времени на обновление и меньше времени на чтение этого документа.

### Кэширование базы данных

Если вы включите системный параметр **cache_db**, MODX может автоматически кэшировать наборы результатов базы данных, извлеченные любым экземпляром `xPDOCriteria` или `xPDOQuery`. Это включает в себя все наборы результатов, представляющие `xPDOObjects` или коллекции `xPDOObjects`, возвращаемые такими методами, как `getObject` и `getCollection`.

Эта функция может быть включена в средах, где доступ к базе данных обходится дороже, чем время подключения файлов PHP, например, при использовании внешнего сервера базы данных, или настраивается для сред с доступным `memcached`, `APC` или другими системами кэширования. Это отдельный раздел кеша в MODX, поэтому его можно настроить с другими обработчиками кэша. Смотрите [xPDO Caching](extending-modx/xpdo/caching) для дополнительной информации.

## Обновление кэша MODX Core

Чтобы обновить любой из основных разделов кэша MODX, используйте метод `modCacheManager->refresh()`. Минимальный вызов не имеет параметров и обновит все разделы основного кэша.

```php
$modx->cacheManager->refresh();
```

Кроме того, вы можете определить массив `$providers` с разделом элементов `key => $partitionOptions`.

```php
// Обновить только настройки контекстов web и web2
$modx->cacheManager->refresh(array('context_settings'=>array('contexts'=> array ('web', 'web2')));
```

Второй параметр `$results` передается по ссылке и будет содержать результаты каждого раздела кэша. В зависимости от раздела это может быть логическое значение или массив с дополнительной информацией о результате обновления определенного раздела. Сама функция возвращает логическое значение, указывающее, вернул ли какой-либо из разделов логическое значение `false`.

## Программное (пользовательское) кэширование

Взаимодействуя с `modCacheManager`, вы можете легко кэшировать данные любого типа. Есть несколько полезных функций, которые вы можете использовать для поддержания рабочего кэша. Используя `modCacheManager` с пользовательским разделом (хотя и необязательно), пользователи вашего кода могут изменить обработчик кэша и сохранить данные в экземпляре `memcached`, `APC` или `WinCache` вместо файлового кэша по умолчанию.

`ModCacheManager` (производный от `xPDOCacheManager`) предоставляет следующие полезные методы:

-   `add($key, $var, $life = 0, $options = array())` используется для добавления значения в кэш, но только если оно еще не существует или срок его действия истек.
-   `replace($key, $var, $life = 0, $options = array())` используется для замены существующего кэшированного значения другим.
-   `set($key, $var, $life = 0, $options = array())` используется для установки значения в кэш независимо от того, существует ли оно уже (перезаписывается) или нет (добавляется).
-   `delete($key, $options = array())` удаляет кэшированное значение из кэша.
-   `get($key, $options = array())` получает кэшированное значение из кэша.
-   `clean($options = array())` очищает (удаляет) весь поставщик кэша. Убедитесь, что вы определили `xPDO::OPT_CACHE_KEY` в массиве параметров.

В общем случае вы можете использовать `get($key)` и `set($key, $value)` для получения и установки значений соответственно, но дополнительные методы обеспечивают дополнительный контроль над способом управления данными.

Массив `$options` может содержать следующие параметры, указывающие раздел кэша для записи, используемый обработчик кэша и время истечения по умолчанию.

-   `xPDO::OPT_CACHE_KEY` - раздел кэша для записи.
-   `xPDO::OPT_CACHE_HANDLER` - используемый обработчик кэша. Как правило, вам не нужно жестко определять этот параметр, но имеет смысл разрешать конкретной реализации обрабатывать обработчик кэша с помощью системных настроек (то есть системных настроек `cache_PARTITION_handler`).
-   `xPDO::OPT_CACHE_EXPIRES` - время истечения по умолчанию.

### Пример 1: Простое добавление и получение кэша

```php
$str = 'Мои тестовые данные для кэша.';

// Записываем данные в раздел кеша по умолчанию со сроком действия 2 часа.
$modx->cacheManager->set('testdata', $str, 7200);

// Получаем данные из кеша снова. Возвращается ноль, если кеш недоступен или срок его действия истек.
$str = $modx->cacheManager->get('testdata');
```

### Пример 2. Добавление и получение кэша из пользовательского раздела

```php
$str = 'Мои тестовые данные для кэша.';

$options = array(xPDO::OPT_CACHE_KEY=>'mypartition',);

// Записываем данные в раздел кеша по умолчанию со сроком действия 2 часа.
$modx->cacheManager->set('testdata', $str, 7200, $options);

// Получаем данные из кеша снова. Возвращается ноль, если кеш недоступен или срок его действия истек.
$str = $modx->cacheManager->get('testdata', $options);
```

## Обратите внимание в Revolution 2.0

В MODX Revolution 2.0 была другая система кеширования с отличающимися разделами. Чтобы очистить кеш в 2.0, вы должны использовать метод `clearCache()`, который устарел с 2.1. Лучше обновиться до последней версии, чем продолжать использовать 2.0.

```php
// Очищаем всё по умолчанию (все файлы с расширением .cache.php
// в cachePath + все кэши объектов)
$modx->cacheManager->clearCache();

// очищаем только файлы кэша с расширением .php или .log в путях web/, custom/
// или logs/; объекты не очищаются
$paths = array('web/', 'custom/', 'logs/');

$options = array('objects'=>null, 'extensions'=> array('. php', '.log'));

$modx->cacheManager->clearCache($paths, $options);

// очищаем все файлы кеша с расширением .php в cachePath
// + все объекты + выполняем проверки по времени публикации
$paths = array('');
$options = array('objects'=>'*', 'publishing'=>true, 'extensions'=>array('. php'));
$modx->cacheManager->clearCache($paths, $options);
```
